다 쓴 객체 참조를 해제하라
==========================  
자바의 가비지 컬렉터를 경험하게 된다면 다 쓴 객체를 알아서 회수해가니 매우 편리할 것이다.     
그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데 절대 사실이 아니다.    

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elemets = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if(size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }
    
    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.  
     * 배열 크기를 늘려야 할 때마다 대략 두배씩 늘린다.   
     */
     private void ensureCapacity() {
         if(elements.length == size) {
             elements = Arrays.copyOf(elements, 2 * size + 1);
         }
     }
}
```
특별한 문제가 없어보이지만 사실 **메모리 누수**가 발생하고 있다.(OutOfMemoryError)       
이 코드에서는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 GC가 회수하지는 않는다.           
프로그램에서 **그 객체들을 더 이상 사용하지 않더라도 결과적으로 배열에서 참조를 여전히 가지고 있기 때문이다.**        

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elemetns[size] = null;
    return result;
}
```
해법은 간단하다.     
해당 참조를 다 썼을때 `null 처리(참조 해제)` 하면 된다.     
스택 클래스에서는 각 원소의 참조가 더 이상 필요 없어지는 시점은 스택에서 꺼내질 때다.   
그렇기에 `pop()`과 동시에 꺼내진 객체에 대해서 `null` 처리를 해주면 좋다.   
      
혹여나 실수로 null 처리한 영역에 접근하다 하더라도      
`NullPointerException`이 발생하기에 프로그램 오류를 조기에 발견할 수 있다.       
     
## null 처리 오해   
이러한 문제와 해결법으로 인해 null 처리를 하는데 혈안이 되기도 한다.      
하지만, 그럴 필요도 없고 바람직하지 않으며 프로그램을 필요 이상으로 지저분하게 만들 뿐이다.     
**객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.**   
다 쓴 참조를 해제하는 것으로 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것이다.      
    
**그렇다면 언제 null 처리를 하는 것이 좋을까? 🤔**      
위 스택 클래스 같은 경우는 메모리를 직접 관리하기에 메모리 누수가 발생했던 것이다.           
int를 통해 `활성 영역`을 지정해주었지만, GC에서는 이를 알리는 없고 그냥 사용중인 객체라 생각할 뿐이다.              
**그렇기에 `비 활성화 영역`이 된 순간 `null` 처리하여 해당 객체는 더이상 사용하지 않을 것이라 GC에 알려야한다.**       
  
정리하자면       
**자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야하며**            
**원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해줘야 한다.**       

## 캐시   
**캐시 역시 메모리 누수를 일으키는 주범이다.**      
캐시의 크기를 너무 비대하게 만들어 놀고 있는 객체가 있다면 이는 곧 메모리 낭비로 이어지는 것이다.       
이를 해결하기 앞서 언급했던 null 을 이용하여 해제를 할 수 있지만        
WeakHasHMap 을 이용해 캐시를 만들면 다 쓴 엔트리는 그 즉시 자동으로 제거 될 것이다.       
  
캐시를 만들 때 보통은 캐시 엔티르의 유효 기간을 정확히 정의하기 어렵기 때문에         
시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다.     
이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 한다.       
백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다.       
`LinkedHashMap`은 `removeEldestEntry()`를 써서 후자의 방식으로 처리하고 있다.        
더 복잡한 캐시를 만들고 싶다면 `java.lang.ref` 패키지를 직접 활용해야 할 것이다.        
  
## 리스너와 콜백  
리스너 혹은 콜백 또한 메모리 누수의 주범이 된다.          
클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면,          
뭔가 조치해주지 않는 한 콜백은 계속 쌓여갈 것이다.          
이럴 때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해야한다.     
예를 들면 WeakHasMap에 키로 저장하면 된다.      

**핵심 정리**  
메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다.      
이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야하만 발견되기도 한다.        
그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.       





  






