다 쓴 객체 참조를 해제하라
==========================  
자바의 가비지 컬렉터를 경험하게 된다면 다 쓴 객체를 알아서 회수해가니 매우 편리할 것이다.     
그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데 절대 사실이 아니다.    

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elemets = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if(size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }
    
    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.  
     * 배열 크기를 늘려야 할 때마다 대략 두배씩 늘린다.   
     */
     private void ensureCapacity() {
         if(elements.length == size) {
             elements = Arrays.copyOf(elements, 2 * size + 1);
         }
     }
}
```
특별한 문제가 없어보이지만 사실 **메모리 누수**가 발생하고 있다.(OutOfMemoryError)       
이 코드에서는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 GC가 회수하지는 않는다.           
프로그램에서 **그 객체들을 더 이상 사용하지 않더라도 결과적으로 배열에서 참조를 여전히 가지고 있기 때문이다.**        

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elemetns[size] = null;
    return result;
}
```
해법은 간단하다.     
해당 참조를 다 썼을때 null 처리(참조 해제) 하면 된다.     
스택 클래스에서는 각 원소의 참조가 더 이상 필요 없어지는 시점은 스택에서 꺼내질 때다.   
그렇기에 pop()과 동시에 꺼내진 객체에 대해서 null 처리를 해주면 좋다.   
  
혹여나 실수로 null 처리한 영역에 접근하다 하더라도      
NullPointerException이 발생하기에 프로그램 오류를 조기에 발견할 수 있다.     

## 오해 
이러한 문제와 해결법으로 인해 null 처리를 하는데 혈안이 되기도 한다.    
하지만, 그럴 





