finalize와 cleaner 사용을 피하라
==================================
**finalizer는 예측할 수 없고 상황에 따라 위험할 수 있어 일반적으로 불필요하다.**          
`오동작`, `낮은 성능`, `이식성 문제`의 원이이 되기도 하며 일반적으로 **사용하지 말아야 한다.**        
JDK 9에서는 애초에 finalizer를 deprecated API로 지정고 그 대안으로 `cleaner`를 소개하고 있다.   
그러나, **cleaner 또한, finalizer 보다는 덜 위험하지만 여전히 예측할 수 없고, 느리고 일반적으로 불필요하다.**      
      
## finalizer 와 cleaner를 만약 사용한다 하더라도 즉시 수행한다는 보장은 없다.**     
finalizer나 cleaner를 얼마나 신속히 수행할지는 전적으로 GC에 알고리즘에 달려있으며         
이는 GC 구현 마다 천차 만별이기 때문에 모든 코드에 동일한 실행 시점을 지정하기는 힘들다.            
  
## finalizer와 cleaner는 다른 애플리케이션 스레드보다 우선 순위가 낮아 실행 기회를 얻기도 힘들다.**      

## 자바 언어 명세는 finalizer나 cleaner의 수행 시점뿐 아니라 수행 여부조차 보장하지 않는다.**             
접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수 있다는 얘기다.       
따라서 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.    
 
## System.gc나 System.runFinalization 메서드에 현혹되지 말자**   
이들 또한 실행 우선순위를 높여주는 것일 뿐이지 보장해주지는 않는다.      
  
## finalizer 동작 중 발생한 예외는 무시되며 처리할 작업이 남았더라도 그 순간 종료된다.**     
잡지 못한 예외 때문에 해당 객체는 자칫 마무리가 덜 된 상태로 남아있을 수 있다.   
더불어 다른 스레드가 이처럼 훼손된 객체를 사용하려 한다면 어떻게 동작할지 예측할 수 없다.   
  
## finalizer와 cleaner는 심각한 성능 문제도 동반한다**   
finalizer와 cleaner를 사용한다면 GC의 효율을 떨어뜰니다.     
   
## finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수 있다.**         
직렬화 과정에서 예외가 발생하면, 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.     
이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 만들 수 있다.   
이렇게 일그러진 객체가 만들어지고 나면, 이 객체의 메서드를 호출해 애초에는 허용되지 않았을 작업을 수행하는 건 일도 아니다.      
**객체 생성을 막으려면 생성자에서 예외를 던지는 것ㅁ나으로 충분하지만, finalizer가 있다면 그렇지도 않다.**    
final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하짐 않는 finalize 메서드를 만들고 final 관리하자  

    
          



    
