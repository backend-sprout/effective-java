# 불필요한 객체 생성을 피하라   
똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 성능적으로 낫다.       
재사용은 빠르고 세련되고 특히, 불변 객체는 재사용과 같이 사용하기에 매우 좋다.        
  
## new 키워드   
**`new`키워드를 사용하면 메모리를 새로 할당해서 객체를 생성한다.**       
   
```java
String immutableString = "kwj1270";
    
String newString = new String("kwj1270");  
```  
String 은 캐싱이 적용된 불변 객체이지만 `new` 키워드를 사용한다면 메모리를 새로 할당해서 객체를 생성한다.      
       
## 정적 팩터리 메서드를 이용한 캐싱        
**불변 클래스는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.**          
대표적인 예로, `Integer.valueOf()`가 있으며 이 메서드는 127범위내로 캐싱을 적용하여 Integer값을 반환한다.    

```java
Integer one = Intenger.valueOf("1");
Integer first = Intenger.valueOf("1");
  
System.out.println(one == first); -> true    
```

생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않는다.         
불변 객체만이 아니라 가변 객체라 해도 사용중에 변경 되지 않을 것임을 않다면 재사용할 수 있다.     
          
참가로, **생성 비용이 비싼 객체 또한 캐싱을 이용하는 것이 좋다.**     
하지만 자신이 비싼 객체인지는 알기 어렵다는 문제가 있다.    
```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
}
```
      
**`String.maches`는 정규표현식을 문자열 형태로 확인하는 가장 쉬운 방법이지만,    
성능이 중요한 상황에서 반복해서 사용하기에는 적합하지 않다.**   
이 메서드 내부에서 Pattern을 생성하고 바로 GC의 대상이 되기 때문이다.    

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
        
        static boolean isRomanNumeral(String s) {
            return ROMAN.matcher(s).matches();
        }
}
```
성능 개선을 위해 Pattern 인스턴스를 클래스 초기화 과정에서 직접 캐싱해두고,         
나중에 `isRomanNumeral()`가 호출될 때마다 인스턴스를 재사용한다.         
이렇게 개선하면 `isRomanNumeral()`이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다.       











