# 불필요한 객체 생성을 피하라   
똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 성능적으로 낫다.       
재사용은 빠르고 세련되고 특히, 불변 객체는 재사용과 같이 사용하기에 매우 좋다.        
  
## new 키워드   
**`new`키워드를 사용하면 메모리를 새로 할당해서 객체를 생성한다.**       
   
```java
String immutableString = "kwj1270";
    
String newString = new String("kwj1270");  
```  
String 은 캐싱이 적용된 불변 객체이지만 `new` 키워드를 사용한다면 메모리를 새로 할당해서 객체를 생성한다.      
       
## 정적 팩터리 메서드를 이용한 캐싱        
**불변 클래스는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.**          
대표적인 예로, `Integer.valueOf()`가 있으며 이 메서드는 127범위내로 캐싱을 적용하여 Integer값을 반환한다.    

```java
Integer one = Intenger.valueOf("1");
Integer first = Intenger.valueOf("1");
  
System.out.println(one == first); -> true    
```

생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않는다.         
불변 객체만이 아니라 가변 객체라 해도 사용중에 변경 되지 않을 것임을 않다면 재사용할 수 있다.     
    
## 생성 비용이 비싼 객체와 캐싱     
**생성 비용이 비싼 객체 또한 캐싱을 이용하는 것이 좋다.**     
하지만 자신이 비싼 객체인지는 알기 어렵다는 문제가 있다.    
```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
}
```
      
**`String.maches`는 정규표현식을 문자열 형태로 확인하는 가장 쉬운 방법이지만,    
성능이 중요한 상황에서 반복해서 사용하기에는 적합하지 않다.**   
이 메서드 내부에서 Pattern을 생성하고 바로 GC의 대상이 되기 때문이다.    

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
        
        static boolean isRomanNumeral(String s) {
            return ROMAN.matcher(s).matches();
        }
}
```
성능 개선을 위해 Pattern 인스턴스를 클래스 초기화 과정에서 직접 캐싱해두고,         
나중에 `isRomanNumeral()`가 호출될 때마다 인스턴스를 재사용한다.             
이렇게 개선하면 `isRomanNumeral()`이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다.             
(물론, 사용하지 않는다면 자원 낭비이기에 지연 초기화를 생각할 수 있지만 이는 권하지 않는다.)       
    
## 보이지 않는 캐싱   
객체가 불변이라면 재사용해도 안전함이 명백하다.            
하지만 **훨씬 덜 명확하거나, 심지어 직관에 반대되는 상황도 있다.**          

```java
public class SearchFindAdapter implements SearchStrategy{
    private final FindAlgorithm findAlgorithm;                      // 뒷단 객체  

    public SearchFindAdapter(FindAlgorithm _findAlgorithm){
        findAlgorithm = _findAlgorithm; 
    }

    @Override
    public void search() {        
        findAlgorithm.find(true);
    }
}
```   
어댑터는 **실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체다.**    
어댑터는 인터페이스와 뒷단 객체를 연결해주는 것이기에 **뒷단 객체만 관리하면 된다.**            
즉, 뒷단 객체 외에는 관리할 상태가 없으므로 **뒷단 객체 하나당 어댑터 하나씩만 만들면 충분하다.**         
                 
## 오토박싱의 문제점  
**오토박싱은 불필요한 객체를 만들어낸다는 문제를 가지고 있다.**   
오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.      

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
논리적 로직만 보면 문제가 없고 잘 돌아갈 것 같지만 사실은 아니다.       
i가 Long으로 바뀌는 횟수가 `2^31`번 돌아가고 매번 새로운 Long 객체를 만들기 때문이다.      
즉, **Long 객체가 `2^31`번 만들어지는 과정을 반복하고 있다.**       
        
이로 인한 교훈은 명확하다.       
**박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**        
   
## 주의점       
이번 아이템을 `객체 생성은 비싸니 피해야 한다`고 오해하면 안된다.       
특히 요즘의 JVM은 객체를 생성하고 회수하는 일에 크게 부담을 느끼지 않는다.           
프로그램의 명확성, 간결성, 기능을 이해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.       
       
거꾸로 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 객체 풀을 만들지는 말자.                   
물론, 데이터베이스 연결 같은 경우 생성 비용이 워낙 비싸니 재사용하는 편이 낫다.            
그러나 일반적으로 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.           
요즘의 JVM의 가비지 컬렉터는 상당히 잘 최적화 되어있어서 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.          
    
이후 이번 아이템인 `기존 객체를 재사용해야한다면 새로운 객체를 만들지 마라`와        
대조적으로 `새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라`는 아이템이 나온다.        
방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가       
필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다는 사실을 기억하자         
방어적 복사에 실패하면 언제 터져나올지 모르는 버그와 보안 구멍으로 이어지지만,     
객체 생성은 그저 코드 형태와 성능에만 영향을 준다.   














