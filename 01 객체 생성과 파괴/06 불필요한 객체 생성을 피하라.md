# 불필요한 객체 생성을 피하라   
똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 성능적으로 낫다.       
재사용은 빠르고 세련되고 특히, 불변 객체는 재사용과 같이 사용하기에 매우 좋다.        
  
## new 키워드   
**`new`키워드를 사용하면 메모리를 새로 할당해서 객체를 생성한다.**       
   
```java
String immutableString = "kwj1270";
    
String newString = new String("kwj1270");  
```  
String 은 캐싱이 적용된 불변 객체이지만 `new` 키워드를 사용한다면 메모리를 새로 할당해서 객체를 생성한다.      
       
## 정적 팩터리 메서드를 이용한 캐싱        
**불변 클래스는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.**          
대표적인 예로, `Integer.valueOf()`가 있으며 이 메서드는 127범위내로 캐싱을 적용하여 Integer값을 반환한다.    

```java
Integer one = Intenger.valueOf("1");
Integer first = Intenger.valueOf("1");
  
System.out.println(one == first); -> true    
```

생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않는다.         
불변 객체만이 아니라 가변 객체라 해도 사용중에 변경 되지 않을 것임을 않다면 재사용할 수 있다.     
    
## 생성 비용이 비싼 객체와 캐싱     
**생성 비용이 비싼 객체 또한 캐싱을 이용하는 것이 좋다.**     
하지만 자신이 비싼 객체인지는 알기 어렵다는 문제가 있다.    
```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
}
```
      
**`String.maches`는 정규표현식을 문자열 형태로 확인하는 가장 쉬운 방법이지만,    
성능이 중요한 상황에서 반복해서 사용하기에는 적합하지 않다.**   
이 메서드 내부에서 Pattern을 생성하고 바로 GC의 대상이 되기 때문이다.    

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD]|D?C{0,3})"    
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0.3})$");
        
        static boolean isRomanNumeral(String s) {
            return ROMAN.matcher(s).matches();
        }
}
```
성능 개선을 위해 Pattern 인스턴스를 클래스 초기화 과정에서 직접 캐싱해두고,         
나중에 `isRomanNumeral()`가 호출될 때마다 인스턴스를 재사용한다.             
이렇게 개선하면 `isRomanNumeral()`이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다.             
(물론, 사용하지 않는다면 자원 낭비이기에 지연 초기화를 생각할 수 있지만 이는 권하지 않는다.)       
    
## 보이지 않는 캐싱   
객체가 불변이라면 재사용해도 안전함이 명백하다.            
하지만 **훨씬 덜 명확하거나, 심지어 직관에 반대되는 상황도 있다.**          

```java
public class SearchFindAdapter implements SearchStrategy{
    private final FindAlgorithm findAlgorithm;                      // 뒷단 객체  

    public SearchFindAdapter(FindAlgorithm _findAlgorithm){
        findAlgorithm = _findAlgorithm; 
    }

    @Override
    public void search() {        
        findAlgorithm.find(true);
    }
}
```   
어댑터는 **실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체다.**    
어댑터는 인터페이스와 뒷단 객체를 연결해주는 것이기에 **뒷단 객체만 관리하면 된다.**            
즉, 뒷단 객체 외에는 관리할 상태가 없으므로 **뒷단 객체 하나당 어댑터 하나씩만 만들면 충분하다.**         
                 
## 오토박싱의 문제점  
**오토박싱은 불필요한 객체를 만들어낸다는 문제를 가지고 있다.**   
오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.      

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
논리적 로직만 보면 문제가 없고 잘 돌아갈 것 같지만 사실은 아니다.       
i가 Long으로 바뀌는 횟수가 `2^31`번 돌아가고 매번 새로운 Long 객체를 만들기 때문이다.      
즉, **Long 객체가 `2^31`번 만들어지는 과정을 반복하고 있다.**       
        
이로 인한 교훈은 명확하다.       
**박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**        
.



0 











