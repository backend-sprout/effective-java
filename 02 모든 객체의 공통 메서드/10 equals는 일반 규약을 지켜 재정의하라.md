equals()는 일반 규약을 지켜 재정의하라
==============================  
자바에서 객체는 일반적으로 메모리 주소값을 기준으로 비교를 한다.             
그런데 만약 객체의 주소가 아닌 값을 기준으로 동등성을 비교하고자 한다면 어떻게해야할까?          
답은 간단하다. **`equals()`를 재정의하여 두 객체간의 논리적으로 동일함을 맞춰주면 된다.**      
                         
**단, equals() 를 재정의 하는데에는 몇 가지 주의 사항이 있다.**                
그렇기에 어설프게 재정의해서 코드를 망치는 것보다는 그대로 사용하는 것이 나을 수 있다.         
우선, 열거한 사항 중 하나에 해당한다면 재정의 하지 않는 것이 좋다.   
          
* **✔ 각 인스턴스가 본질적으로 고유하다.**    
  값이 아닌 동작하는 개체를 표현하는 클래스가 여기에 해당되며 Thread가 대표적이다.        
   
* **✔ 인스턴스의 논리적 동치성을 검사할 일이 없다.**    
  메모리 주소값을 통해서만 값을 비교한다면 굳이 정의할 필요가 없다.       
     
* **✔ 상위 클래스에서 정의한 `equals()`가 하위 클래스에도 딱 들어맞는다.**        
  상속 받은 `equals()`를 그대로 이용하면 된다.      
  클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없다.       
  혹여나 equals가 실수로라도 호출되는 걸 막고 싶다면 아래처럼 구현하자     
  ```java
      @Override public boolean equals(Object o) {
          throw new AssertionError();
      }
  ```
      
**equals()를 재정의해야할 때는 언제일까? 🤔**     
`논리적 동치성`을 확인해야하는데 `equals()`가 이에 맞춰 정의 되어있지 않을때이다.            
주로, `VO`에서 재정의하며 이를 통해 `Map`, `Set`도 동치성을 기준으로 동작을 한다.           
참고로, 2번 이상 생성되지 않는 VO 또는 Enum 클래스는 굳이 `equals()`를 정의하지 않아도 된다.      
이런 클래스에서는 어차피 논리적으로 동치성 검사를 할 필요가 없기 때문이다.                 
         
**equals()를 재정의 할 때는 반드시 일반 규약을 따라야 한다.**   
* **반사성 :** null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.   
* **대칭성 :** null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.   
* **추이성 :** null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고 y.equals(z) 도 true면 x.equals(z)도 true이다.  
* **일관성 :** null이 아닌 모든 참조 값 x,y 에 대해 x.equals(y)를 반복해서 호출하면 항상 true/false를 반환한다.   
* **nul-아님 :** null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false 이다.   
  
컬렉션을 포함해서 많은 클래스는 전달받은 객체가 equals() 규약을 지킨다고 가정하고 동작한다.       

## 동치관계  
동치관계란, 집합을 서로 같은 원소들로 이루어진 부분 집합으로 나누는 연산이다.     

* 반사성 : 객체는 자기 자신과 같아야 한다.  
* 대칭성 : 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.   
* 추이성 : 1번 객체와 2번 객체가 같고, 2번 객체와 3번 객체가 같으면 1번 객체와 3번 객체도 같다.    
* 일관성 : 두 객체가 같다면 앞으로도 영원히 같아야 한다  
* 






