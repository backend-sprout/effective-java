equals()는 일반 규약을 지켜 재정의하라
==============================
**equals() 를 재정의 하는 것은 쉬워보이지만 몇가지 주의해야할 사항이 많다.**      
그렇기에 어설프게 재정의해서 코드를 망치는 것보다는 재정의 하지 않는 것이 더 나을 수 있다.   
다음 열거한 상항 중 하나에 해당한다면 재정의 하지 않는 것이 최선이다.   
   
* **각 인스턴스가 본질적으로 고유하다.**  
  * 값이 아닌 동작하는 개체를 표현하는 클래스가 여기에 해당되며 Thread가 대표적이다.      
* **인스턴스의 논리적 동치성을 검사할 일이 없다.**
  * 메모리 주소값을 통해서만 값을 비교한다면 굳이 정의할 필요가 없다.  
* 상위 클래스에서 정의한 `equals()`가 하위 클래스에도 딱 들어맞는다.   
  * 상속 받은 `equals()`를 그대로 이용하면 된다.  
* 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없다.    
  * 혹여나 equals가 실수로라도 호출되는 걸 막고 싶다면 아래처럼 구현하자   
    ```java
    @Override public boolean equals(Object o) {
        throw new AssertionError();
    }
    ```

**그렇다면 equals()를 정의해야할 때는 언제일까? 🤔**     
객체 식별성이 아니라 논리적 동치성을 확인해야하는데 equals가 이에 맞춰 정의 되어있지 않을때이다.          
주로 `VO`가 이에 해당되며 이를 통해 `Map`, `Set`도 객체의 동치성을 기준으로 동작을 한다.        
 
참고로 VO 또한 동일한 값을 가진 객체가 2번 이상 만들어 지지 않는다면 굳이 equals를 정의하지 않아도 된다.         
Enum 도 여기에 속한다. 이런 클래스에서는 어차피 논리적으로 동치성 검사를 할 필요가 없기 때문이다.           
    
**equals()를 재정의 할 때는 반드시 일반 규약을 따라야 한다.**   
* **반사성 :** null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.   
* **대칭성 :** null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.   
* **추이성 :** null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고 y.equals(z) 도 true면 x.equals(z)도 true이다.  
* **일관성 :** null이 아닌 모든 참조 값 x,y 에 대해 x.equals(y)를 반복해서 호출하면 항상 true/false를 반환한다.   
* **nul-아님 :** null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false 이다.   
  
컬렉션을 포함해서 많은 클래스는 전달받은 객체가 equals() 규약을 지킨다고 가정하고 동작한다.       

## 동치관계  
동치관계란, 집합을 서로 같은 원소들로 이루어진 부분 집합으로 나누는 연산이다.     

* 반사성 : 객체는 자기 자신과 같아야 한다.  
* 대칭성 : 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.   
* 추이성 : 1번 객체와 2번 객체가 같고, 2번 객체와 3번 객체가 같으면 1번 객체와 3번 객체도 같다.    
* 일관성 : 두 객체가 같다면 앞으로도 영원히 같아야 한다  
* 






