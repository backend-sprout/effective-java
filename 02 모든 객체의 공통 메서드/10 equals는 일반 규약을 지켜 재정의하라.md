equals()는 일반 규약을 지켜 재정의하라
==============================
**equals() 를 재정의 하는 것은 쉬워보이지만 몇가지 주의해야할 사항이 많다.**      
그렇기에 어설프게 재정의해서 코드를 망치는 것보다는 재정의 하지 않는 것이 더 나을 수 있다.   
다음 열거한 상항 중 하나에 해당한다면 재정의 하지 않는 것이 최선이다.   
   
* **각 인스턴스가 본질적으로 고유하다.**  
  * 값이 아닌 동작하는 개체를 표현하는 클래스가 여기에 해당되며 Thread가 대표적이다.      
* **인스턴스의 논리적 동치성을 검사할 일이 없다.**
  * 메모리 주소값을 통해서만 값을 비교한다면 굳이 정의할 필요가 없다.  
* 상위 클래스에서 정의한 `equals()`가 하위 클래스에도 딱 들어맞는다.   
  * 상속 받은 `equals()`를 그대로 이용하면 된다.  
* 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없다.    
  * 혹여나 equals가 실수로라도 호출되는 걸 막고 싶다면 아래처럼 구현하자   
    ```java
    @Override public boolean equals(Object o) {
        throw new AssertionError();
    }
    ```

**그렇다면 equals()를 정의해야할 때는 언제일까? 🤔**     
객체 식별성이 아니라 논리적 동치성을 확인해야하는데 equals가 이에 맞춰 정의 되어있지 않을때이다.          
주로 `VO`가 이에 해당되며 이를 통해 `Map`, `Set`도 객체의 동치성을 기준으로 동작을 한다.        
 
참고로 VO 또한 동일한 값을 가진 객체가 2번 이상 만들어 지지 않는다면 굳이 equals를 정의하지 않아도 된다.         
Enum 도 여기에 속한다. 이런 클래스에서는 어차피 논리적으로 동치성 검사를 할 필요가 없기 때문이다.           
    
**equals()를 재정의 할 때는 반드시 일반 규약을 따라야 한다.**   
* **반사성 :** null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.   
* **대칭성 :** null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.   
*
*
*
*





