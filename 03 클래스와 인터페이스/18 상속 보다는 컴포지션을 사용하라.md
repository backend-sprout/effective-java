상속 보다는 컴포지션을 사용하라
==================================
상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다.          
**잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.**        

상/하위 클래스가 동일 패키지로 프로그래머가 통제할 수 있다면 비교적 안전하다.   
확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다.   

그러나, 패키지 경계를 넘거나 단순 재사용이나 문서화가 잘 안된 상속은 매우 위험하다.   
  
**메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.**     
하위 클래스는 상위 클래스에 의존적인 형태가 되기에     
상위 클래스의 구현에 따라 하위 클래스의 동작에 이상이 생길 수 있다.     

이외에도 하위 클래스가 깨지지 쉬운 이유는 더 있다.    
다음 릴리스에서 상위 클래스에 새로운 메서드를 추가한다면?  
보안 때문에 컬렉션에 추가된 모든 원소가 특정 조건을 만족해야만 하는 프로그램을 생각해보자    
그 컬렉션을 상속하여 원소를 추가하는 모든 메서드를 재정의해 필요한 조건을 먼저 검사하게끔 하면 된다.    
하지만 이 방식이 통하는 것은 상위 클래스에 또다른 원소 추가 메서드가 만들어지기 전까지이다.     
다음 릴리스에서 우려한 일이 생기면   
하위 클래스에서 재정의하지 못한 그 새로운 메서드를 사용해 허용되지 않은 원소를 추가할 수 있게 된다.  
   
따라서 클래스를 확장하더라도 **메서드를 재정의하는 대신 새로운 메서드를 추가하는 생각이 들 수 있다.**   
이 방식 또한 훨씬 안전한 것은 맞지만, 위험이 전혀 없는 것은 아니다.   
상위 클래스에 새로운 메서드를 추가했는데   
운 나쁘게 하위 클래스의 메서드 시그니처가 일치하고 반환값이 다르면 컴파일 조차 되지 않는다.       
  
다행히 이상의 문제를 모두 피해가는 묘안이 있다.      
**기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게하자**       
기존 클래스가 새로운 클래스의 구성요소로 쓰인다고해서 **컴포지션이라고 부른다.**      
         
새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.       
이 방식을 **전달**이라 하며, 새 클래스의 메서드들을 **전달 메서드**라 부른다.(전달 메서드가 전달을 활용)   
그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며,  
심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지않는다.     

```java
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;
    
    public InstrumentedSet(Set<E> s) {
        super(s);
    }
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    
    @Override public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }
    
    public int getAddCount() {
        return addCount;
    }
}
```

```java
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    
    private ForwardingSet(Set<E> s) {
        this.s = s;
    }
    
    public void clear()               { s.clear(); }
    public boolean contains(Object o) { return s.contains(o); }
    public boolean isEmpty()          { return s.isEmpty(); }
    public int size()                 { return s.size(); } 
    public Iterator<E> iterator()     { return s.iterator(); }
    public boolean add(E e)           { return s.add(e); }
    public boolean remove(Object o)   { return s.remove(o); }
    ...// 생략
}
```
`InstrumentedSet`은 HashSet의 모든 기능을 정의한 Set 인터페이스를 활용해 설계되어 견고하고 아주 유연하다.     
구체적으로는 Set 인터페이스를 구현했고 Set의 인스턴스를 인수로 받는 생성자를 하나 제공한다.   
임의의 Set에 계층 기능을 덧씌워 새로운 Set을 만드는 것이 이 클래스의 핵심이다.     
 
상속 방식은 구체 클래스를 각각 따로 확장해야 하며,      
지원하고 싶은 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의해줘야한다.       
하지만 지금 선보인 컴포지션 방식은 한 번만 구현해두면 어떠한 Set 구현체라도 계측할 수 있으며,   
기존 생성자들과도 함께 사용할 수 있다.   

```java
Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp));
Set<E> s = new InstrumentedSet<>(new HashSet<>(INIT_CAPACITY));
```











