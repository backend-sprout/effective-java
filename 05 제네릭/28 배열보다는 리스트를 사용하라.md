배열보다는 리스트를 사용하라
=======================
# 공변 불공변
배열은 공변이다.   
`sub`가 `super 타입`의 하위 타입이라면 배열 `sub[]`는 `배열 super[]`의 하위 타입이 된다.       

제네릭은 불공변이다.   
서로 다른 타입 Type1, Type2 가 있을 때, `List<Type1>`은 `List<Type2>`의 하위/상위도 아니다.  

```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입을 달리 넣을 수 없다."; // ArrayStoreException 을 던진다.  
```  
자바에서는 배열에 저장된 타입이 다를 경우를 대비해서 `ArrayStoreException` 를 반환하지만   
문제는 런타임시에 확인할 수 있다.  

```java
List<Object> ol = new ArrayList<>();   
ol.add("타입이 달라 넣을 수 없다");   
```
제네릭 또한, String 값을 넣을 수 없지만 컴파일시에 확인할 수 있다는 장점을 가지고 있다.    

# 실채화 여부 
배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하는 **실체화가 된다.**    
그래서 Long 배열에 String을 넣으려하면 에러를 발생했던 것이다.   

반면, 제네릭은 타입 정보가 런타입에는 소거된다.     
즉, 원소타입을 컴파일에만 검사하여 런타임에는 알 수 조차 없다는 뜻이다.    
참고로, 타입 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 매커니즘이다.       
   
이상의 주요 차이로 인해 배열과 제네릭은 잘 어울리지 못한다.     
예컨대 배열은 `new List<E>[]`과 같은 코드를 작성할 수 없다.   
  
제네릭 배열을 만들지 못하게 한 이유는 무엇일까? 🤔      
타입이 안전하지 않기 때문이다.     
이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임 에러가 발생할 수 있다.        
이러면 컴파일 타임에서 에러를 잡겠다는 제네릭의 취지에 어긋난다.     




