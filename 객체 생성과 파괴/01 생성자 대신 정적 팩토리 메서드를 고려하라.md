
생성자 대신 정적 팩토리 메서드를 고려하라  
==============================================

클래스의 인스턴스를 얻는 전통적인 수단은 `public 생성자`이다.    
이 외에도 생성자와 별도로 `정적 팩터리 메서드(static factory method)`를 제공할 수 있다.     

**Boolean 예시**
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```
  
**kwj1270 예시**
```java
    public static final Ladder from(final List<Line> lines) {
        return new Ladder(lines);
    }

    private Ladder(final List<Line> lines) {
        validateNull(lines);
        this.lines = lines;
    }
```
   
정적 팩터리 메서드는 기존에 존재하는 생성자를 `private`로 변환환 뒤          
`public static 클래스 이름() {}`을 통해 인스턴스 생성 기능을 수행한다.         
     
# 정적 팩터리 메서드의 장점 
## 이름을 가질 수 없다. 
생성자는 `new 클래스()` 형태이기에 좀더 명확한 의미를 갖는 이름을 가지고 있지는 않다.     
더불어 `new 클래스()`이므로 두가지 단어를 한 번에 관리해야한다는 단점도 있다.       

**이름 지정**
```java
    public static final Ladder from(final List<Line> lines) {
        return new Ladder(lines);
    }
```
반면, `정적 팩터리 메서드`는 메서드 형태로 인스턴스를 생성하는 것이기에 **특정 이름을 정의할 수 있다.**     
   
**동일 시그니처 다른 로직 메서드 구현**   
```java
    public static final Samples first(final List<Sample> samples) {
        return new Samples(lines);
    }
    public static final Samples second(final List<Sample> samples) {
        return new Samples(samples.subList(FROM_INDEX, TO_INDEX);
    }
```

기존에 존재하는 생성자와 동일한 시그니처를 가진 생성자는 정의할 수 없다.           
그러나 정적 팩터리 메서드는 **동일한 시그니처를 가진 여러 메서드들을 정의할 수 있다.**      
(동일 메서드 판별 기준은 `이름`과 `시그니처`를 기준으로 하기 때문이다.)      

## 인스턴스를 새로 생성하지 않아도 된다.   
인스턴스를 미리 만들어 놓거나 인스터스를 캐싱하여 재활용하는 식으로 **불필요한 객체 생성을 피할 수 있다.**                      
따라서 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어줄 수 있다.      
   
```java
public final class Pins {

    private static final int EMPTY = 0;
    private static final int FULL = 10;
    private static final List<Pins> CACHE;

    private final int count;

    static {
        CACHE = new ArrayList<>();
        for (int count = EMPTY; count <= FULL; count++) {
            CACHE.add(new Pins(count));
        }
    }

    public static final Pins valueOf(final int count) {
        validateSize(count);
        return CACHE.get(count);
    }

    public Pins(final int count) {
        validateSize(count);
        this.count = count;
    }
```  
    
[플라이웨이트 패턴]()
     
이렇듯, 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는         
**언제 어느 인스턴스를 살아있게 할지를 철저히 통제**할 수 있으며 이를 **인스턴스 통제 클래스라 한다.**      
    
**그렇다면 왜 인스턴스를 통제해야하는 것일까? 🤔**       
인스턴스를 통제하는 이유는 클래스를 `싱글톤`, `인스턴스화 불가`로 만들 수 있다.         
또한, 불변 값 클래스에서 동치인 인스턴스가 단 하나임을 보장할 수 있다.         
인스턴스 통제는 플라이웨이트 패턴의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.     









## 반환 타입의 하위 타입 객체를 반환할 수 있다.  
이름 그대로 팩토리 기능을 가지고 있다. 

## 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다.  

## 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.   


# 추가로 
![image](https://user-images.githubusercontent.com/50267433/125010810-38f77f80-e0a2-11eb-8ef0-14d86adce881.png)


