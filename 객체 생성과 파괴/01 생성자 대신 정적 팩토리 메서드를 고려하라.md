
생성자 대신 정적 팩토리 메서드를 고려하라  
==============================================

클래스의 인스턴스를 얻는 전통적인 수단은 `public 생성자`이다.    
이 외에도 생성자와 별도로 `정적 팩터리 메서드(static factory method)`를 제공할 수 있다.     

**Boolean 예시**
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```
  
**kwj1270 예시**
```java
    public static final Ladder from(final List<Line> lines) {
        return new Ladder(lines);
    }

    private Ladder(final List<Line> lines) {
        validateNull(lines);
        this.lines = lines;
    }
```
   
정적 팩터리 메서드는 기존에 존재하는 생성자를 `private`로 변환환 뒤          
`public static 클래스 이름() {}`을 통해 인스턴스 생성 기능을 수행한다.         
     
# 정적 팩터리 메서드의 장점 
## 이름을 가질 수 없다. 
생성자는 `new 클래스()` 형태이기에 좀더 명확한 의미를 갖는 이름을 가지고 있지는 않다.     
더불어 `new 클래스()`이므로 두가지 단어를 한 번에 관리해야한다는 단점도 있다.       

**이름 지정**
```java
    public static final Ladder from(final List<Line> lines) {
        return new Ladder(lines);
    }
```
반면, `정적 팩터리 메서드`는 메서드 형태로 인스턴스를 생성하는 것이기에 **특정 이름을 정의할 수 있다.**     
   
**동일 시그니처 다른 로직 메서드 구현**   
```java
    public static final Samples first(final List<Sample> samples) {
        return new Samples(lines);
    }
    public static final Samples second(final List<Sample> samples) {
        return new Samples(samples.subList(FROM_INDEX, TO_INDEX);
    }
```

기존에 존재하는 생성자와 동일한 시그니처를 가진 생성자는 정의할 수 없다.           
그러나 정적 팩터리 메서드는 **동일한 시그니처를 가진 여러 메서드들을 정의할 수 있다.**      
(동일 메서드 판별 기준은 `이름`과 `시그니처`를 기준으로 하기 때문이다.)      

## 인스턴스를 새로 생성하지 않아도 된다.   
인스턴스를 미리 만들어 놓거나       
새로 생성한 인스터스를 캐싱하여 재활용하는 식으로            
**불필요한 객체 생성을 피할 수 있다.**              

[플라이웨이트 패턴]()





## 반환 타입의 하위 타입 객체를 반환할 수 있다.  
이름 그대로 팩토리 기능을 가지고 있다. 

## 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다.  

## 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.   


# 추가로 
![image](https://user-images.githubusercontent.com/50267433/125010810-38f77f80-e0a2-11eb-8ef0-14d86adce881.png)


